from enaml.application import deferred_call
from enaml.core.api import Looper
from enaml.layout.api import align, hbox, InsertTab, spacer, TabLayout, vbox
from enaml.stdlib.fields import FloatField
from enaml.stdlib.message_box import information, question
from enaml.widgets.api import (Action, ButtonGroup, CheckBox, Container,
                               DockArea, DockItem, FileDialogEx, Form, HGroup,
                               Html, Label, MainWindow, Menu, MenuBar,
                               MPLCanvas, ObjectCombo, PushButton, Slider)


def bind(figure, presenter):
    figure.canvas.mpl_connect('key_press_event', lambda e: presenter.key_press(e))
    figure.canvas.mpl_connect('button_press_event', lambda e: presenter.button_press(e))
    figure.canvas.mpl_connect('button_release_event', lambda e: presenter.button_release(e))
    figure.canvas.mpl_connect('scroll_event', lambda e: presenter.scroll(e))
    figure.canvas.mpl_connect('motion_notify_event', lambda e: presenter.motion(e))


def add_dock_item(dock_area, presenter):
    items = dock_area.dock_items()
    n_items = len(items)
    target = items[-1].name if n_items else ''

    item = MPLDockItem(dock_area, name='dock_{}'.format(n_items), presenter=presenter)
    op = InsertTab(item=item.name, target=target)
    dock_area.update_layout(op)


def save_state(parent, presenters):
    q = 'Your previous analysis will be overwritten. Are you sure?'
    button = question(parent, 'Confirm action', q)
    if button.text == 'Yes':
        for presenter in presenters:
            presenter.save_state()
        information(parent, 'Analysis saved', 'Analysis has been saved.')


def load_state(parent, presenters):
    if any(p.unsaved_changes for p in presenters):
        q = 'There are unsaved changes. Your current analysis will be lost. Are you sure?'
        button = question(parent, 'Confirm action', q)
        if button.text == 'No':
            return
    for presenter in presenters:
        presenter.load_state()
    information(parent, 'Analysis loaded', 'Analysis has been loaded.')



CELLS = ['IHC', 'OHC1', 'OHC2', 'OHC3']


enamldef MPLDockItem(DockItem):

    attr presenter
    closable = False

    title << 'Piece {}{}'.format(presenter.piece.piece, '*' if presenter.unsaved_changes else '')

    Container: container:
        constraints = [
            vbox(
                hbox(display_label, display_channel, display_as_label,
                     display_mode, z_slice_number_label, z_slice,
                     display_apply, highlight_selected),
                hbox(mode_label, mode_buttons, submode_buttons, spacer),
                hbox(action_label, action_clear_spiral, action_clear_cells,
                     spacer, load_analysis, save_analysis, spacing=0),
                action_guess_cells,
                canvas,
            ),
            align('v_center', display_label, display_channel, display_as_label,
                  display_mode, z_slice_number_label, z_slice, display_apply,
                  highlight_selected),
            align('v_center', mode_label, mode_buttons),
            align('v_center', action_label, action_clear_spiral,
                  action_clear_cells),
            align('left', display_label, mode_label, action_label),
            align('left', display_channel, mode_buttons, action_clear_spiral,
                  action_guess_cells),
            submode_buttons.children[0].width == mode_buttons.children[0].width,
        ]

        Label: display_label:
            text = 'Display'

        ObjectCombo: display_channel:
            items = ['All', 'CtBP2', 'MyosinVIIa']
            selected << presenter.current_artist.display_channel
            selected ::
                presenter.set_display_channel(selected, display_apply.checked)

        Label: display_as_label:
            text = 'as'

        ObjectCombo: display_mode:
            items = ['projection', 'slice']
            selected << presenter.current_artist.display_mode
            selected ::
                presenter.set_display_mode(selected, display_apply.checked)

        Label: z_slice_number_label:
            text = 'number'
            enabled << display_mode.selected == 'slice'

        Slider: z_slice:
            enabled << display_mode.selected == 'slice'
            tick_interval = 1
            value << presenter.current_artist.z_slice
            value ::
                presenter.set_z_slice(value, display_apply.checked)
            minimum << presenter.current_artist.z_slice_min
            maximum << presenter.current_artist.z_slice_max

        PushButton: display_apply:
            text = 'Apply to all tiles'
            checkable = True
            checked = True
            clicked ::
                if checked:
                    presenter.set_display_mode(display_mode.selected, True)
                    presenter.set_display_channel(display_channel.selected, True)

        PushButton: highlight_selected:
            text = 'Highlight selected'
            checkable = True
            checked := presenter.highlight_selected

        ButtonGroup: mode_group:
            pass

        ButtonGroup: submode_group:
            pass

        Label: mode_label:
            text << 'Edit'

        HGroup: mode_buttons:
            padding = 0
            spacing = 0
            Looper:
                iterable = ['tiles'] + CELLS
                PushButton:
                    text = loop_item
                    group = mode_group
                    checkable = True
                    checked << loop_item == presenter.interaction_mode
                    checked ::
                        presenter.interaction_mode = loop_item

        HGroup: submode_buttons:
            padding = 0
            spacing = 0
            Looper:
                iterable = ['spiral', 'exclude', 'cells']
                PushButton:
                    enabled << presenter.interaction_mode != 'tiles'
                    text = loop_item
                    group = submode_group
                    checkable = True
                    checked << loop_item == presenter.interaction_submode
                    checked ::
                        presenter.interaction_submode = loop_item

        Label: action_label:
            text = 'Actions'

        PushButton: action_clear_spiral:
            text = 'Clear spiral'
            enabled << presenter.current_spiral_artist is not None and presenter.current_spiral_artist.has_nodes
            clicked ::
                button = question(self, 'Confirm action', 'Are you sure you want to remove the current spiral?')
                if button.text == 'Yes':
                    presenter.action_clear_spiral()

        PushButton: action_clear_cells:
            text = 'Clear all cells'
            enabled << presenter.current_cells_artist is not None and presenter.current_cells_artist.has_nodes
            clicked ::
                button = question(self, 'Confirm action', 'Are you sure you want to remove the current cells?')
                if button.text == 'Yes':
                    presenter.action_clear_cells()

        PushButton: load_analysis:
            text = 'Load'
            clicked ::
                load_state(self, [presenter])

        PushButton: save_analysis:
            text = 'Save'
            clicked ::
                save_state(self, [presenter])

        HGroup: action_guess_cells:
            padding = 0
            align_widths = False
            trailing_spacer = spacer(0)
            enabled << presenter.current_spiral_artist is not None and presenter.current_spiral_artist.has_spline
            Label:
                text = 'Find cells within'
            FloatField: guess_width:
                value = 5.0
            Label:
                text = 'μm of spline with a spacing of'
            FloatField: guess_spacing:
                value = 5.0
            Label:
                text = 'μm'

            PushButton:
                text = 'update'
                clicked ::
                    button = question(self, 'Confirm action', f'Are you sure you want to overwrite the existing cells?')
                    if button.text == 'Yes':
                        n = presenter.action_guess_cells(guess_width.value * 1e-6, guess_spacing.value * 1e-6)
                        information(self, 'Info', f'Found {n} cells')

        MPLCanvas: canvas:
            figure << presenter.figure
            toolbar_visible = True
            initialized ::
                deferred_call(bind, figure, presenter)


enamldef CochleagramWindow(MainWindow): window:

    initial_size = (900, 900)
    title = 'Cochelogram'

    attr presenters = []

    MenuBar:
        Menu:
            title = '&File'
            Action:
                text = 'Open\tCtrl+O'
                triggered ::
                    path = FileDialogEx.get_existing_directory(window)
                    if path:
                        from cochleogram.model import Cochlea
                        cochlea = Cochlea.from_path(path)
                        window.presenters = [Presenter(p) for p in cochlea.pieces]
                        for p in window.presenters:
                            deferred_call(add_dock_item, workspace, presenter)

            Action:
                text = 'Save analysis\tCtrl+S'
                triggered ::
                    save_state(window, window.presenters)

            Action:
                text = 'Load analysis\tCtrl+L'
                triggered ::
                    load_state(window, window.presenters)

    initialized ::
        for presenter in presenters:
            deferred_call(add_dock_item, workspace, presenter)

    closing ::
        if any(p.unsaved_changes for p in presenters):
            button = question(window, 'Question', 'There are unsaved changes. Are you sure you want to exit?')
            if button.text == 'No':
                change['value'].ignore()

    Container:
        DockArea: workspace:
            name = 'dock_area'

            layout = TabLayout('help')

            DockItem:
                name = 'help'
                title = 'Help'
                closable = False

                Container:
                    Html:
                        source = '''
                        <h3>General interaction</h3>
                        <dl>
                            <dt>right click + drag</dt> <dd>Pan image</dd>
                            <dt>mouse wheel</dt> <dd>Zoom</dd>
                        </dl>

                        <h3>Tile mode</h3>
                        <dl>
                            <dt>left click</dt> <dd>Select tile</dd>
                            <dt>n</dt> <dd>Select next tile</dd>
                            <dt>p</dt> <dd>Select previous tile</dd>
                        </dl>

                        <h3>Spiral mode</h3>
                        <p>You must select a minimum of four points to create
                        the spiral. You can add points in between existing
                        points and the spiral will be rerouted through those
                        points. The algorithm assumes that the "next" point in
                        the path is the one closest to it (i.e., the order in
                        which you add the points does not matter).</p>
                        <dl>
                            <dt>left click</dt> <dd>Add point</dd>
                            <dt>shift + left click</dt> <dd>Remove point</dd>
                            <dt>alt + left drag</dt> <dd>Mark region as bad</dd>
                            <dt>shift + alt + left drag</dt> <dd>Remove bad region</dd>
                        </dl>
                        '''
